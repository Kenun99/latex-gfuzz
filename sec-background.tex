\section{Background}

\subsection{Smart Contracts}
Smart contracts are kind of decentralized application running blockchain. 
Every peer node can execute the smart contract to update blockchain database with consistency. 
Ethereum-favor smart contracts are widely adopted by the popular blockchains, such as Ethereum\cite{wood2014ethereum}, Binance\cite{binance2021whitepaper}, Polkadot\cite{polkadot2021whitepaper}, DAI\cite{dai2021paper}, TRON\cite{tron2021paper} and Avalanche\cite{avalab2021paper}.
These smart contracts are mainly written in Solidity\cite{solidity} and then compiled into bytecode.
Each EVM bytecode is a sequence of opcodes, which can be interpreted by a virtual machine (i.e., EVM) to 1) read input from the read-only \texttt{calldata}; 2) operate runtime operands on stack; 3) access a linear memory; 4) and store persistent data on storage.
Some opcodes are named blockchain APIs because they can access blockchain database and use EVM utility, such as contract calls, storage accesses and Keccak256 computation\cite{bertoni2013keccak}. 

\subsection{CUDA}
% (TBD)
CUDA\cite{nvidia2021cuda} is a parallel computing platform that allows CPU-end programs to use GPUs for general purpose computation. 
In GPU end, the GPU cores creates, manages, schedules, and executes threads in SIMD architecture.
The SIMD architecture is akin to SIMD (Single Instruction, Multiple Data) vector organizations in that a single instruction controls multiple processing elements.
Whenever a group of threads are executed, they start together at the same code address, but they have their own program counter and register states and are therefore free to branch and execute independently.
PTX is the instruction set designed for CUDA GPUs.
The entry point of a PTX application is called kernel function, which can accept data from host and then execute GPU code by invoking devices functions. 
%
The key of GPU-based fuzzing is managing data layout to make sure each fuzzing thread can record its coverage information in its own bitmap memory.   
Fuzzing is an ideal task for GPU because there are no concurrency requirements. All fuzzing iterations are free of branches.